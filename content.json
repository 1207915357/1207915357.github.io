{"meta":{"title":"看不见的城","subtitle":null,"description":null,"author":"看不见的城","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-11-20T12:01:17.000Z","updated":"2018-11-20T12:01:18.011Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-20T11:59:49.000Z","updated":"2018-11-20T11:59:49.504Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"博客主题插件各种配置","slug":"博客主题配置","date":"2018-11-20T08:52:00.000Z","updated":"2018-11-20T08:56:04.355Z","comments":true,"path":"前端/博客主题配置/","link":"","permalink":"http://yoursite.com/前端/博客主题配置/","excerpt":"","text":"今天花了点时间换了下博客的主题，以及配置了一些插件！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"判断数组是否有重复项","slug":"判断数组是否有重复项","date":"2018-07-04T02:20:15.000Z","updated":"2018-07-04T03:06:31.601Z","comments":true,"path":"uncategorized/判断数组是否有重复项/","link":"","permalink":"http://yoursite.com/uncategorized/判断数组是否有重复项/","excerpt":"","text":"给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 方法一：es6 Set方法1234var containsDuplicate = function (nums) &#123; const set = new Set(nums) return set.size != nums.length&#125;; 方法二：sort排序比较临近两项1234567891011121314var containsDuplicate = function(nums) &#123; if(nums.length&lt;=1)&#123; return false &#125; nums.sort(function(a,b)&#123; return a-b &#125;) for(let i =0; i&lt;nums.length-1;i++)&#123; if(nums[i]==nums[i+1])&#123; return true &#125; &#125; return false&#125;; 方法三：利用对象属性1234567891011var containsDuplicate = function(nums) &#123; let obj = &#123;&#125; for(let i of nums)&#123; if(!obj[i])&#123; obj[i]=1 continue //continue 跳过当前循环 &#125; return true &#125; return false&#125;","categories":[],"tags":[{"name":"数组重复","slug":"数组重复","permalink":"http://yoursite.com/tags/数组重复/"}]},{"title":"删除数组重复元素","slug":"删除数组重复元素","date":"2018-07-03T06:09:44.000Z","updated":"2018-07-04T03:05:58.417Z","comments":true,"path":"uncategorized/删除数组重复元素/","link":"","permalink":"http://yoursite.com/uncategorized/删除数组重复元素/","excerpt":"","text":"方法一：使用es6的set快速去重 set 为一种特殊的数据结构，它具有唯一性。Array.from()把伪数转换成数组。 1Array.from(new Set(arr)) 扩展运算符（内部使用的是for…of循环） 1[...new Set(arr)] 方法二：使用对象的属性不能相同去重12345678910Array.prototype.remove=function()&#123; let arr=this,obj=&#123;&#125;,newArr=[] for(i=0; i&lt;arr.length; i++)&#123; if(!obj[arr[i]])&#123; &lt;!--找不到则证明这个元素没有重复--&gt; obj[arr[i]] = 1 newArr.push(arr[i]) &#125; &#125; return newArr&#125; 方法三：双层循环 外层循环元素，内层循环时比较值，如果有相同的值则跳过，不相同则push进数组。 123456789101112Array.prototype.remove= function()&#123; var arr = this, result = [], i, j, for(i = 0; i &lt; arr.length; i++)&#123; for(j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125;&#125; result.push(arr[i]); &#125; return result;&#125; 方法四：splice在原数组进行操作12345678910function removeDuplicates(nums) &#123; for(let i = nums.length-1;i&gt;=0;i--)&#123; for(let j = i-1 ; j&gt;=0; j--)&#123; if(nums[i]==nums[j])&#123; nums.splice(j,1) &#125; &#125; &#125; return nums&#125;","categories":[],"tags":[{"name":"数组去重","slug":"数组去重","permalink":"http://yoursite.com/tags/数组去重/"}]},{"title":"博客的作用","slug":"博客的作用","date":"2018-06-29T09:00:18.000Z","updated":"2018-06-29T09:00:50.254Z","comments":true,"path":"uncategorized/博客的作用/","link":"","permalink":"http://yoursite.com/uncategorized/博客的作用/","excerpt":"","text":"博客的作用1.用来记录容易忘记的知识点。 2.记录有趣的生活。 3.自我提升。","categories":[],"tags":[]},{"title":"正则表达式的运算","slug":"正则表达式的运算","date":"2017-10-18T13:10:03.000Z","updated":"2018-07-03T06:00:20.021Z","comments":true,"path":"uncategorized/正则表达式的运算/","link":"","permalink":"http://yoursite.com/uncategorized/正则表达式的运算/","excerpt":"","text":"##1.正则表达式(regular expression) 1&gt; 正则表达对象:由正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换. 2&gt; 创建正则表达式对象 1)构造函数 var regex= new RegExp( &apos;正则&apos;); var r = new RegExp( &apos;正则&apos;, &apos;g&apos; ); 全局模式 2) 字面量 var regex = /正则表达式/; var r = /正则/g; 全局模式 ​ ##2.使用正则表达式进行匹配 正则对象.test( 字符串 ) 返回boolean值. ##3.基本元字符1&gt; . 表示任一个非换行的字符 2&gt; ( ) 表示分组和提高优先级 3&gt; [ ] 表示一个字符, 出现在 [ ] 中的字符 用法: [abc] 出现 [] 中的任意一个字符 匹配 a, 或 b, 或 c foo[dt] 4&gt; | 或 用法:正则表达式|正则表达式 foot 或 food foot|food foo(t|d) 5&gt;转义字符: \\ 表示点: \\. 表示[]: \\[ \\] 表示(): \\( \\) 表示\\ : \\\\ ##4. 限定元字符1&gt; * 紧跟前面的一个字符或一组字符出现 0 次到多次 2&gt; + 紧跟在前面的字符出现 1 次到多次 3&gt; ? 紧跟在前面的字符出现 0 次或 1 次 4&gt; {数字} 紧跟在前面的字符出现指定次数 a{3} aaa 5&gt; {数字,} 紧跟在前面的字符至少出现指定次数 a{3,} aaa, aaaaaaaaa, aaaaaaaaaaaaaa, ... 6&gt; {数字, 数字} 紧跟在前面的字符出现的次数范围 a{1, 3} a, aa, aaa 7&gt; ^ 表示必须以 xxx 开头 8&gt; $ 表示 必须以 xxx 结尾 9&gt; [^字符] 否定字符,不为这些字符的字符 [^abc] 不是a 也不是b 也不是c 的字符 ##5.提取(重点) 正则表达式对象 . exec( 字符串 ) 返回有一个数组 &lt;script&gt; // 案例： 在 &apos;abc123def456ghij789klum&apos; 提取数字 var str = &apos;abc123def456ghij789klum&apos;; // 1&gt; 全局模式 var r = /\\d+/g; // 2&gt; 匹配要使用循环的方式 var res; while ( res = r.exec( str ) ) { console.log( res ); } &lt;/script&gt; ##6.将匹配到的结果进行解析案例:var str = ‘我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com’要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来 1).如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可（） 2).注意, 正则表达式中, 分组是有编号的. 从左往右数 ‘(‘. 从 1 开始依次编号// 匹配提取的结果中, 对应的编号就可以获得分解的数据 &lt;script&gt; var str = &apos;我有一个邮箱, 是 abc@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com&apos; var r = /([a-zA-Z\\d]+)@([a-zA-Z\\d]+(?:\\.[a-zA-Z\\d]+)+)/g; // var res = r.exec( str ); var res; while ( res = r.exec( str ) ) { console.log( &apos;邮箱是: &apos; + res[ 0 ] + &apos;, 用户名: &apos; + res[ 1 ] + &apos;, 主机名: &apos; + res[ 2 ] ); } &lt;/script&gt; ##7.匹配但是不去捕获的元字符 (?:其他正则表达式内容) 不捕获括号里的内容。 提高性能，避免消耗算法； ##8.要截取一个字符串中的一个 html 标签 反向引用： ‘\\数字’ 的方式引用该组 &lt;script&gt; var str = &apos;123&lt;div&gt;456&lt;/div&gt;78&lt;div&gt;9&lt;/div&gt;0&lt;i&gt;&lt;/i&gt;abc&apos;; var r = /&lt;(\\w+)&gt;.*?&lt;\\/\\1&gt;/g; \\1 表示第一个括号里的内容 var res; while ( res = r.exec(str) ) { console.log( res[ 0 ] ); } &lt;/script&gt; ##9.贪婪模式 1).凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.取消贪婪模式. 在次数限定符后面加上 ? 2).注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题 只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪 3).多个贪婪在一起的时候的强度 \\d+\\d+\\d+ 第一个强度最强 ，后面两个一样。 1234567 12345 6 7 如果取消第一个的贪婪模式 \\d+?\\d+\\d+ 1 23456 7 ##10.替换（字符串方法）1&gt; 字符串替换方法 字符串1.replace( 字符串2, 字符串3 ) 在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串 特点: 只替换第一个找到的字符串 &quot;aaa&quot;.replace( &apos;a&apos;, &apos;A&apos; ) -&gt; &apos;Aaa&apos; 2&gt; 正则替换 字符串.replace( 正则表达式, 字符串 ) -&gt; 字符串 1. 简单替换 &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/, &apos;-&apos; ) &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/g, &apos;-&apos; ) 2. 分组替换 可以在替换字符串中, 使用 $数字 来引用替换的数据（参数中） 类似 \\1 反向引用（用在正则中） &apos;abc123&apos;.replace( /(\\d+)/, &apos;d$1&apos; ) -&gt; &apos;abcd123&apos; &apos;1991-1-1&apos; 中国: 1991年1月1日 欧洲: 1/1/1991 ... : 1991 1 1 &apos;1991-1-19&apos;.replace( /(\\d+)-(\\d+)-(\\d+)/, &apos;$1年$2月$3日&apos; ) 3&gt; 函数参数用法(难点) 语法: 字符串.replace( 正则表达式, fn ) 案例: &apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn&apos; // 要求 只显示 第一个字符, 其余的都是用 * 表示 Var str=&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn&apos;; str.replace( /(\\w+)@(\\w+(\\.\\w+)+)/g, function ( s, g1, g2, g3 ) { // 将用户名 变成 a***** 的形式 var first = g1.charAt( 0 ); var start = []; for ( var i = 0; i &lt; g1.length - 1; i++ ) { start.push( &apos;*&apos; ); } return first + start.join(&apos;&apos;) + &apos;@&apos; + g2; } );","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"我的第一篇博客","slug":"看不见的城","date":"2017-10-18T08:31:48.000Z","updated":"2017-10-18T14:10:03.778Z","comments":true,"path":"uncategorized/看不见的城/","link":"","permalink":"http://yoursite.com/uncategorized/看不见的城/","excerpt":"","text":"进击的巨人.","categories":[],"tags":[{"name":"我的第一篇博客","slug":"我的第一篇博客","permalink":"http://yoursite.com/tags/我的第一篇博客/"}]}]}