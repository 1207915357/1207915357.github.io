<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客主题插件配置]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2F%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今天花了点时间换了下博客的主题，以及配置了一些插件！ 放上几个地址供大家学习参考： https://www.jianshu.com/p/f054333ac9e6 https://www.simon96.online/2018/10/12/hexo-tutorial/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断数组是否有重复项]]></title>
    <url>%2Funcategorized%2F%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 方法一：es6 Set方法1234var containsDuplicate = function (nums) &#123; const set = new Set(nums) return set.size != nums.length&#125;; 方法二：sort排序比较临近两项1234567891011121314var containsDuplicate = function(nums) &#123; if(nums.length&lt;=1)&#123; return false &#125; nums.sort(function(a,b)&#123; return a-b &#125;) for(let i =0; i&lt;nums.length-1;i++)&#123; if(nums[i]==nums[i+1])&#123; return true &#125; &#125; return false&#125;; 方法三：利用对象属性1234567891011var containsDuplicate = function(nums) &#123; let obj = &#123;&#125; for(let i of nums)&#123; if(!obj[i])&#123; obj[i]=1 continue //continue 跳过当前循环 &#125; return true &#125; return false&#125;]]></content>
      <tags>
        <tag>数组重复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除数组重复元素]]></title>
    <url>%2Funcategorized%2F%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[方法一：使用es6的set快速去重 set 为一种特殊的数据结构，它具有唯一性。Array.from()把伪数转换成数组。 1Array.from(new Set(arr)) 扩展运算符（内部使用的是for…of循环） 1[...new Set(arr)] 方法二：使用对象的属性不能相同去重12345678910Array.prototype.remove=function()&#123; let arr=this,obj=&#123;&#125;,newArr=[] for(i=0; i&lt;arr.length; i++)&#123; if(!obj[arr[i]])&#123; &lt;!--找不到则证明这个元素没有重复--&gt; obj[arr[i]] = 1 newArr.push(arr[i]) &#125; &#125; return newArr&#125; 方法三：双层循环 外层循环元素，内层循环时比较值，如果有相同的值则跳过，不相同则push进数组。 123456789101112Array.prototype.remove= function()&#123; var arr = this, result = [], i, j, for(i = 0; i &lt; arr.length; i++)&#123; for(j = i + 1; j &lt; arr.length; j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125;&#125; result.push(arr[i]); &#125; return result;&#125; 方法四：splice在原数组进行操作12345678910function removeDuplicates(nums) &#123; for(let i = nums.length-1;i&gt;=0;i--)&#123; for(let j = i-1 ; j&gt;=0; j--)&#123; if(nums[i]==nums[j])&#123; nums.splice(j,1) &#125; &#125; &#125; return nums&#125;]]></content>
      <tags>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的作用]]></title>
    <url>%2Funcategorized%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[博客的作用1.用来记录容易忘记的知识点。 2.记录有趣的生活。 3.自我提升。]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的运算]]></title>
    <url>%2Funcategorized%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[##1.正则表达式(regular expression) 1&gt; 正则表达对象:由正则表达式创建的对象, 该对象可以进行 匹配, 提取 和 替换. 2&gt; 创建正则表达式对象 1)构造函数 var regex= new RegExp( &apos;正则&apos;); var r = new RegExp( &apos;正则&apos;, &apos;g&apos; ); 全局模式 2) 字面量 var regex = /正则表达式/; var r = /正则/g; 全局模式 ​ ##2.使用正则表达式进行匹配 正则对象.test( 字符串 ) 返回boolean值. ##3.基本元字符1&gt; . 表示任一个非换行的字符 2&gt; ( ) 表示分组和提高优先级 3&gt; [ ] 表示一个字符, 出现在 [ ] 中的字符 用法: [abc] 出现 [] 中的任意一个字符 匹配 a, 或 b, 或 c foo[dt] 4&gt; | 或 用法:正则表达式|正则表达式 foot 或 food foot|food foo(t|d) 5&gt;转义字符: \ 表示点: \. 表示[]: \[ \] 表示(): \( \) 表示\ : \\ ##4. 限定元字符1&gt; * 紧跟前面的一个字符或一组字符出现 0 次到多次 2&gt; + 紧跟在前面的字符出现 1 次到多次 3&gt; ? 紧跟在前面的字符出现 0 次或 1 次 4&gt; {数字} 紧跟在前面的字符出现指定次数 a{3} aaa 5&gt; {数字,} 紧跟在前面的字符至少出现指定次数 a{3,} aaa, aaaaaaaaa, aaaaaaaaaaaaaa, ... 6&gt; {数字, 数字} 紧跟在前面的字符出现的次数范围 a{1, 3} a, aa, aaa 7&gt; ^ 表示必须以 xxx 开头 8&gt; $ 表示 必须以 xxx 结尾 9&gt; [^字符] 否定字符,不为这些字符的字符 [^abc] 不是a 也不是b 也不是c 的字符 ##5.提取(重点) 正则表达式对象 . exec( 字符串 ) 返回有一个数组 &lt;script&gt; // 案例： 在 &apos;abc123def456ghij789klum&apos; 提取数字 var str = &apos;abc123def456ghij789klum&apos;; // 1&gt; 全局模式 var r = /\d+/g; // 2&gt; 匹配要使用循环的方式 var res; while ( res = r.exec( str ) ) { console.log( res ); } &lt;/script&gt; ##6.将匹配到的结果进行解析案例:var str = ‘我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com’要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来 1).如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可（） 2).注意, 正则表达式中, 分组是有编号的. 从左往右数 ‘(‘. 从 1 开始依次编号// 匹配提取的结果中, 对应的编号就可以获得分解的数据 &lt;script&gt; var str = &apos;我有一个邮箱, 是 abc@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com&apos; var r = /([a-zA-Z\d]+)@([a-zA-Z\d]+(?:\.[a-zA-Z\d]+)+)/g; // var res = r.exec( str ); var res; while ( res = r.exec( str ) ) { console.log( &apos;邮箱是: &apos; + res[ 0 ] + &apos;, 用户名: &apos; + res[ 1 ] + &apos;, 主机名: &apos; + res[ 2 ] ); } &lt;/script&gt; ##7.匹配但是不去捕获的元字符 (?:其他正则表达式内容) 不捕获括号里的内容。 提高性能，避免消耗算法； ##8.要截取一个字符串中的一个 html 标签 反向引用： ‘\数字’ 的方式引用该组 &lt;script&gt; var str = &apos;123&lt;div&gt;456&lt;/div&gt;78&lt;div&gt;9&lt;/div&gt;0&lt;i&gt;&lt;/i&gt;abc&apos;; var r = /&lt;(\w+)&gt;.*?&lt;\/\1&gt;/g; \1 表示第一个括号里的内容 var res; while ( res = r.exec(str) ) { console.log( res[ 0 ] ); } &lt;/script&gt; ##9.贪婪模式 1).凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.取消贪婪模式. 在次数限定符后面加上 ? 2).注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题 只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪 3).多个贪婪在一起的时候的强度 \d+\d+\d+ 第一个强度最强 ，后面两个一样。 1234567 12345 6 7 如果取消第一个的贪婪模式 \d+?\d+\d+ 1 23456 7 ##10.替换（字符串方法）1&gt; 字符串替换方法 字符串1.replace( 字符串2, 字符串3 ) 在 字符串1 中找到 字符串2, 将其替换成 字符串3, 返回替换后的字符串 特点: 只替换第一个找到的字符串 &quot;aaa&quot;.replace( &apos;a&apos;, &apos;A&apos; ) -&gt; &apos;Aaa&apos; 2&gt; 正则替换 字符串.replace( 正则表达式, 字符串 ) -&gt; 字符串 1. 简单替换 &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/, &apos;-&apos; ) &apos;aaaaa-------bbbbbb------ccccc&apos;.replace( /-+/g, &apos;-&apos; ) 2. 分组替换 可以在替换字符串中, 使用 $数字 来引用替换的数据（参数中） 类似 \1 反向引用（用在正则中） &apos;abc123&apos;.replace( /(\d+)/, &apos;d$1&apos; ) -&gt; &apos;abcd123&apos; &apos;1991-1-1&apos; 中国: 1991年1月1日 欧洲: 1/1/1991 ... : 1991 1 1 &apos;1991-1-19&apos;.replace( /(\d+)-(\d+)-(\d+)/, &apos;$1年$2月$3日&apos; ) 3&gt; 函数参数用法(难点) 语法: 字符串.replace( 正则表达式, fn ) 案例: &apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: def@itcast.cn&apos; // 要求 只显示 第一个字符, 其余的都是用 * 表示 Var str=&apos;我的邮箱是:abc@itcast.cn, 你的邮箱是: defghijklim@itcast.cn&apos;; str.replace( /(\w+)@(\w+(\.\w+)+)/g, function ( s, g1, g2, g3 ) { // 将用户名 变成 a***** 的形式 var first = g1.charAt( 0 ); var start = []; for ( var i = 0; i &lt; g1.length - 1; i++ ) { start.push( &apos;*&apos; ); } return first + start.join(&apos;&apos;) + &apos;@&apos; + g2; } );]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2Funcategorized%2F%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[进击的巨人.]]></content>
      <tags>
        <tag>我的第一篇博客</tag>
      </tags>
  </entry>
</search>
